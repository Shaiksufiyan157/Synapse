"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class XHRPromise {
    get(url, options) {
        return XHRPromise.makeRequest('GET', url, undefined, options);
    }
    post(url, data, options = {}) {
        // If there is a file, it needs to retrieve native data.
        const parsedData = typeof data === 'string' || typeof data === 'undefined' ? data : data.data;
        return XHRPromise.makeRequest('POST', url, parsedData, options);
    }
    put(url, data, options = {}) {
        return XHRPromise.makeRequest('PUT', url, data, options);
    }
    delete(url, options = {}) {
        return XHRPromise.makeRequest('DELETE', url, undefined, options);
    }
    static makeRequest(method, url, data, options = {}) {
        return new Promise(function (resolve, reject) {
            const xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            XHRPromise.setHeaders(xhr, options);
            XHRPromise.setEncoding(xhr, options);
            // Success handling.
            xhr.onload = function () {
                // Success case.
                if (this.status >= 200 && this.status < 300) {
                    // Transform response if it was configured.
                    const { transformResponse } = options;
                    const response = !!transformResponse ? transformResponse(this.response) : this.response;
                    resolve(response);
                    return;
                }
                // Failure cases.
                // Binary enabled but with error. I do this due to inside a browser
                // DOM after a binary download error, the state of xhr is invalid and
                // can cause other errors if the object is examinated.
                if (XHRPromise.isBinary(options)) {
                    reject({
                        status: this.status,
                        statusText: 'File could not be downloaded.',
                    });
                    return;
                }
                else {
                    const parsedResponse = JSON.parse(this.responseText);
                    // Servers haven't got a unique error response.
                    const { error, name, message } = parsedResponse;
                    let status;
                    let statusText;
                    if (!!error) {
                        const { code, message } = error;
                        status = code;
                        statusText = message;
                    }
                    else {
                        status = this.status;
                        statusText = `${name} - ${message}`;
                    }
                    reject({
                        status,
                        statusText
                    });
                }
            };
            // Error handling.
            xhr.onerror = function () {
                reject({
                    status: this.status,
                    statusText: this.statusText
                });
            };
            // Send.
            xhr.send(data);
        })
            .catch(error => {
            throw error;
        });
    }
    static setHeaders(xhr, options = {}) {
        if (!!options.headers) {
            options.headers.forEach(([key, value]) => {
                xhr.setRequestHeader(key, value);
            });
        }
    }
    static setEncoding(xhr, options = {}) {
        // Enable arraybuffer as a return type when binary is enabled.
        if (XHRPromise.isBinary(options))
            xhr.responseType = 'arraybuffer';
    }
    ;
    static isBinary(options) {
        return !!options.binary;
    }
}
exports.default = XHRPromise;
//# sourceMappingURL=XHRPromise.js.map